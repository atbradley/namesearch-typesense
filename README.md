# Fake Name Search with Typesense

This repository contains a small project demonstrating a simple name and address search using Typesense, including vector search capabilities.  It's pretty basic, but it shows how to set up a Typesense schema, load data, and perform hybrid (text + vector) searches.

## What's Inside

There are three main Python scripts:

1.  **`makefakenames.py`**:  Generates a list of fake names and addresses.  Think of it as a little data factory.  You can run this to create the initial dataset.

2.  **`loadnames.py`**: This is the Typesense setup script.  It does two things:
    *   Creates a Typesense schema (see below for details). This defines the structure of the data we'll be storing.
    *   Loads the fake names and addresses (generated by `makefakenames.py`) into Typesense.  It also calculates Double Metaphones for each name (an attempt to handle misspellings, though Typesense's built-in fuzzy matching seems to work well enough on its own).  Finally, it creates embeddings for the name and address fields.

3.  **`querynames.py`**:  A simple command-line tool for searching the names.  Just run it and type in a name (or part of a name/address).  It uses a hybrid search query (explained below).

## The Typesense Schema

The data is structured like this in Typesense:

```json
{
    "name": "names",  // Replace "names" with your collection name
    "fields": [
        {"name": "name", "type": "string"},
        {"name": "address_1", "type": "string"},
        {"name": "address_2", "type": "string"},
        {"name": "metaphones", "type": "string[]"},
        {
            "name": "embedding",
            "type": "float[]",
            "embed": {
                "from": [
                    "name",
                    "address_1",
                    "address_2"
                ],
                "model_config": {"model_name": "ts/e5-large-v2"},
            },
        },
    ],
    "enable_nested_fields": false
}
```

## The Hybrid Search Query 

The querynames.py script uses the following query: 

```json
{
    "collection": "names",  // Replace "names" with your collection name
    "q": "<your_search_term>",
    "query_by": "embedding, name",
    "vector_query": "embedding:([], alpha: 0.8)",
    "exclude_fields": "embedding",
    "prefix": false,
    "remote_embedding_timeout_ms": 5000,
    "remote_embedding_num_try": 3,
    "per_page": 5
}
```

## Notes:

q : This is where your search term goes.
query_by :  It searches both the embedding (vector search) and name (text search) fields.
vector_query :  This part configures the vector search. alpha: 0.8 means it gives more weight to the traditional text search (20% vector, 80% text).
exclude_fields : This omits the large embedding field in the search results.
prefix :  false means it doesn't do prefix matching (searching for "Jo" won't automatically return "John").  You could change this if you want.
remote_embedding_timeout_ms: Timeout, in milliseconds for embedding vectors.
remote_embedding_num_try: Number of retries, in case of failure.
per_page :  It shows the top 5 results.
    

This is a hybrid search, combining the results of both the text and vector searches.  It seems to work pretty well for finding names even with typos.

## Getting Started 

If you have [`uv`](https://docs.astral.sh/uv/) installed, you should be able to run any of these scripts with, e.g. `uv run loadnames.py`. Run the scripts in the order they're listed in above (or skip `makefakenames.py` and just use the provided `fake_names.csv`).

If you aren't using `uv`, you'll probably need to create a virtual environment then `pip install typesense faker metaphone`.

You'll also need to create a config.ini with, at a minimum:

```
[typesense]
api_key=<your Typesense api key>
```
